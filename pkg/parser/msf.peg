{
package parser

}

// We have values, which are the basic unit of predicates, and consist of a string, number or boolean
Value ⟵ StringVal / NumberVal / LiteralVal

// We include true, false and nil, directly as Val types, not as raw data
LiteralVal ⟵ LVTrue / LVFalse / LVNull / LVNil
LVTrue ⟵ "true"i {
    return Val{typ: ValTypeBool, bl: true}, nil
}
LVFalse ⟵ "false"i {
    return Val{typ: ValTypeBool, bl: false}, nil
}
LVNull ⟵ "null"i {
    return Val{typ: ValTypeNil}, nil
}
LVNil ⟵ "nil"i {
    return Val{typ: ValTypeNil}, nil
}

// We include a Val{} form of strings
StringVal ⟵ str:String {
    return Val{typ: ValTypeString, str: str.(string)}, nil
}

// We handle quoted strings using PHP style ' or " characters, and unquoting
// as required
String ⟵ DoubleString / SingleString / UnquotedString
// Single quoted string follow PHPs rules for escpaing
SingleString ⟵ SingleQuote chr:( !SingleEscapedChar . / '\\' SingleEscapeSequence )* SingleQuote {
    return strunquote(string(c.text))
}
SingleEscapedChar ⟵ [\x00-\x1f'\\]
SingleEscapeSequence ⟵ SingleCharEscape / UnicodeEscape
SingleCharEscape ⟵ ['bfnrt]
SingleQuote ⟵ "'"
// DoubleQuotedStrings also follow PHPs rules for escaping
DoubleString ⟵ DoubleQuote ( !DoubleEscapedChar . / '\\' DoubleEscapeSequence )* DoubleQuote {
    return strunquote(string(c.text))
}
DoubleEscapedChar ⟵ [\x00-\x1f"\\]
DoubleEscapeSequence ⟵ DoubleCharEscape / UnicodeEscape
DoubleCharEscape ⟵ ["bfnrt]
DoubleQuote ⟵ "\""
// Unquoted strings are only valid as standalone double braced specifiers
UnquotedString ⟵ "{{" Whitespace? UnquotedIdentifier Whitespace? "}}" {
    return string(c.text), nil
}
UnquotedIdentifier ⟵ [0-9a-zA-Z._\\-]+
// Helper types for strings
Whitespace ⟵ [\t\n\v\f\r ]+ {
    return " ", nil
}
UnicodeEscape ⟵ 'u' HexDigit HexDigit HexDigit HexDigit
HexDigit ⟵ [0-9a-f]i

// We create a type incorporating numbers into
// a Val{} struct for usage in more complex constructs
NumberVal ⟵ ZeroErr / FloatVal / IntegerVal
FloatVal ⟵ flt:Float {
    return Val{typ: ValTypeFloat, flt: flt.(float64)}, nil
}
IntegerVal ⟵ itg:(Integer / ZeroVal) {
    return Val{typ: ValTypeInt, itg: itg.(int64)}, nil
}

// We parse out the typical numeric types, including
// erroring on -0, etc.
Number ⟵ ZeroErr / Float / Integer / ZeroVal
Float ⟵ Neg? Flt {
    fmt.Printf("Float capturing '%s'\n", c.text)
    return strconv.ParseFloat(string(c.text), 64)
}
Integer ⟵ Neg? Int {
    fmt.Printf("Integer capturing\n")
    return strconv.ParseInt(string(c.text), 10, 64)
}
Flt ⟵ Int Dot Int / Int Dot ZeroStr / ZeroStr Dot Int / ZeroStr Dot / Int Dot {
    fmt.Printf("Flt capturing\n")
    return strconv.ParseFloat(string(c.text), 64)
}
Int ⟵ [1-9][0-9]* {
    fmt.Printf("Int capturing\n")
    return c.text, nil
}
ZeroStr ⟵ "0" {
    return "0", nil
}
ZeroVal ⟵ "0" {
    return int64(0), nil
}
ZeroErr ⟵ Neg? "0.0" {
    return nil, errors.New("Invalid 0.0")
}
Dot ⟵ "."
Neg ⟵ "-"

// That's all folks
EOF ⟵ !.